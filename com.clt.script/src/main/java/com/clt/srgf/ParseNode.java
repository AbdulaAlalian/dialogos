/*
 * @(#)ParseNode.java
 * Created on Thu Sep 16 2004
 *
 * Copyright (c) 2004 CLT Sprachtechnologie GmbH.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of CLT Sprachtechnologie GmbH ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with CLT Sprachtechnologie GmbH.
 */

package com.clt.srgf;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;

import javax.swing.tree.TreeNode;

/**
 * The base class for all nodes in a parse tree generated by
 * {@link Grammar#parse}.
 * 
 * @author Daniel Bobbert
 * @version 2.0
 */

public abstract class ParseNode
    implements TreeNode {

  List<ParseNode> children = new ArrayList<ParseNode>();

  private ParseNode parent;


  public ParseNode() {

    this.parent = null;
  }


  void setParent(ParseNode parent) {

    this.parent = parent;
  }


  public TreeNode getParent() {

    return this.parent;
  }


  public ParseNode getChildAt(int index) {

    return this.children.get(index);
  }


  public int getChildCount() {

    return this.children.size();
  }


  public boolean isLeaf() {

    return !this.getAllowsChildren();
  }


  public void insertChild(ParseNode child, int index) {

    if (this.getAllowsChildren()) {
      this.children.add(index, child);
      child.setParent(this);
    }
    else {
      throw new UnsupportedOperationException();
    }
  }


  public ParseNode removeChildAt(int index) {

    ParseNode n = this.children.remove(index);
    n.setParent(null);
    return n;
  }


  public int getIndex(TreeNode child) {

    return this.children.indexOf(child);
  }


  public Enumeration<ParseNode> children() {

    return new Enumeration<ParseNode>() {

      int n = 0;


      public boolean hasMoreElements() {

        return this.n < ParseNode.this.getChildCount();
      }


      public ParseNode nextElement() {

        return ParseNode.this.getChildAt(this.n++);
      }
    };
  }


  abstract public boolean getAllowsChildren();


  abstract ParseNode clone(Map<ParseNode, ParseNode> mapping);


  @Override
  abstract public int hashCode();


  @Override
  abstract public boolean equals(Object o);


  public void print(PrintWriter p) {

    this.print(p, 0, true);
  }


  private void print(PrintWriter w, int indent, boolean printHashes) {

    for (int i = 0; i < indent; i++) {
      w.print("  ");
    }
    w.print(this.toString());
    if (printHashes) {
      w.print(" (");
      w.print(this.hashCode());
      w.print(")");
    }
    w.println();
    for (Enumeration<ParseNode> e = this.children(); e.hasMoreElements();) {
      e.nextElement().print(w, indent + 1, printHashes);
    }
  }


  protected void printHash(PrintWriter w) {

    w.print(this.hashCode());
  }
}
