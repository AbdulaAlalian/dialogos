/* * @(#)JavaDocument.java	1.2 98/05/04 * * Copyright (c) 1998 Sun Microsystems, Inc. All Rights Reserved. * * This software is the confidential and proprietary information of Sun * Microsystems, Inc. ("Confidential Information").  You shall not * disclose such Confidential Information and shall use it only in * accordance with the terms of the license agreement you entered into * with Sun. * * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE * SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR * PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR ANY DAMAGES * SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING * THIS SOFTWARE OR ITS DERIVATIVES. * */package com.clt.gui.editor;import java.io.IOException;import java.io.Reader;import java.util.Collection;import java.util.Vector;import javax.swing.event.ChangeEvent;import javax.swing.event.ChangeListener;import javax.swing.text.AttributeSet;import javax.swing.text.BadLocationException;import javax.swing.text.Document;import javax.swing.text.GapContent;import javax.swing.text.PlainDocument;import javax.swing.text.Segment;/** * A document to represent text in the form of the java programming language. * This is quite primitive in that it simply provides support for lexically * analyzing the text. *  * @author Timothy Prinzing * @version 1.2 05/04/98 */public class SyntaxDocument    extends PlainDocument {  Scanner scanner;  Symbol[] tokens;  Collection<ChangeListener> changeListeners = new Vector<ChangeListener>();  ChangeEvent changeEvent = new ChangeEvent(this);  public SyntaxDocument(Scanner scanner) {    super(new GapContent(1024));    this.scanner = scanner;  }  /**   * Create a lexical analyzer for this document.   */  public Scanner getScanner() {    return this.scanner;  }  public void addChangeListener(ChangeListener l) {    this.changeListeners.add(l);  }  public void removeChangeListener(ChangeListener l) {    this.changeListeners.remove(l);  }  /*   * public void insertString(int offset, String str, AttributeSet a) throws   * BadLocationException { //System.out.println("Insert at " + offset + ": \""   * + str + "\""); // keep indent int index = str.indexOf('\n'); if (index >=   * 0) { String text = getText(0, offset); int lastBreak =   * text.lastIndexOf('\n'); if (lastBreak >= 0) { StringBuilder indent = new   * StringBuilder(); for (int i=lastBreak+1; i<offset &&   * Character.isWhitespace(text.charAt(i)); i++) indent.append(text.charAt(i));   * if (indent.length() > 0) { StringBuilder b = new StringBuilder(str.length()   * + indent.length()); int start = 0; do { b.append(str.substring(start,   * index+1)); b.append(indent); start = index+1; index = str.indexOf('\n',   * start); } while (index >= 0); if (start < str.length())   * b.append(str.substring(start)); str = b.toString(); } } }   * super.insertString(offset, str, a); }   */  // --- AbstractDocument methods ----------------------------  @Override  protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {    this.tokens = null;    super.insertUpdate(chng, attr);  }  @Override  protected void removeUpdate(DefaultDocumentEvent chng) {    this.tokens = null;    super.removeUpdate(chng);  }  public Symbol[] getSymbols(int start, int end) {    if (this.tokens == null) {      this.tokens = this.scanner.parse(new DocumentReader(this));      for (ChangeListener l : this.changeListeners) {        l.stateChanged(this.changeEvent);      }    }    if (this.tokens.length == 0) {      return new Symbol[] { new Symbol() {        public int getStart() {          return 0;        }        public int getStyle() {          return 0;        }      } };    }    else {      start = this.getSymbol(start, 0, this.tokens.length - 1);      end = this.getSymbol(end, start, this.tokens.length - 1);      Symbol[] symbols = new Symbol[end - start + 1];      for (int i = 0; i < symbols.length; i++) {        symbols[i] = this.tokens[start + i];      }      return symbols;    }  }  private int getSymbol(int position, int left, int right) {    if (left == right) {      return left;    }    else {      int mid = (left + right) / 2 + 1;      if (position < this.tokens[mid].getStart()) {        return this.getSymbol(position, left, mid - 1);      }      else {        return this.getSymbol(position, mid, right);      }    }  }  /**   * Class to provide Reader functionality from a Document.   */  private static class DocumentReader        extends Reader {    private static final int SEGMENT_SIZE = 1024;    Document document;    Segment segment;    int end; // end position    int pos; // pos in document    int index; // index into array of    // the segment    public DocumentReader(Document document) {      this.document = document;      this.segment = new Segment();      // try to force document to return chunks without making a copy      this.segment.setPartialReturn(true);      this.pos = 0;      this.end = document.getLength();      this.index = 0;    }    @Override    public void close() {      // nothing to do    }    @Override    public int read()        throws IOException {      if (this.index >= this.segment.offset + this.segment.count) {        if (this.pos >= this.end) {          // no more data          return -1;        }        this.loadSegment();      }      return this.segment.array[this.index++];    }    @Override    public int read(char[] buffer, int offset, int length)        throws IOException {      if (this.index >= this.segment.offset + this.segment.count) {        if (this.pos >= this.end) {          // no more data          return -1;        }        this.loadSegment();      }      int numChars =        Math.min(this.segment.count - (this.index - this.segment.offset),          length);      System        .arraycopy(this.segment.array, this.index, buffer, offset, numChars);      this.index += numChars;      if (numChars < length) {        int charsRead = this.read(buffer, offset + numChars, length - numChars);        if (charsRead == -1) {          return numChars;        }        else {          return numChars + charsRead;        }      }      else {        return numChars;      }    }    void loadSegment()        throws IOException {      try {        int n = Math.min(DocumentReader.SEGMENT_SIZE, this.end - this.pos);        this.document.getText(this.pos, n, this.segment);        this.pos += this.segment.count;        this.index = this.segment.offset;      } catch (BadLocationException e) {        throw new IOException("Bad location");      }    }  }}